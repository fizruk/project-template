{-Логика работы примерно такая:
находим строку или столбец, наиболее удобный для раскраски;
раскрашиваем в нем все, что можем;
смотрим, не позволяют ли нам внесенные изменения что-то раскрасить в других столбцах/строках (рекурсивно);
проверяем, не закончилась ли игра;
если нет - все сначала
-}

type Field a = [ [ a ] ] --игровое поле  --игровое поле (список списков) 
                         --сами клетки Just Bool - если закрашено, то True, если клетка точно пустая, то False, иначе пока Nothing
    { fieldHeight :: Height
    , fieldWidth :: Width
    }
                     

type InfoPoint = ([[Cnt]], Int) --то, что стоит в начале каждой строки/столбца - список из типа ниже,
                              -- и число, обозначающее количество еще не закрашенных клеток в строке/столбце 
type Cnt = (Int, Bool) --заданные условием числа, обозначающие количество закрашенных клеток подряд, и булевская переменная, показывающая, отметили мы их уже или еще нет

ch_rowstr :: Field -> Int --выбор наиболее подходящего для рассмотрения ряда или строки (стоит рассматривать те, где нужно больше всего раскрашивать/где меньше всего еще не закрашенных)
    

colour :: Field -> Field --основная функция раскраски, 
                         --раскрашивает выбранный столбец/строку

check_changes :: Field -> Int -> Bool -> Bool  --проверка тех строк/столбцов, которые также были изменены; первый Bool должен указывать на то, смотреть на строку или на стобец с таким номером

check_win :: Field -> Bool --проверка, не закончилась ли игра
